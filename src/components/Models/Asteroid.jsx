/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useState, useEffect, useRef, useMemo } from "react";
import { useGLTF } from "@react-three/drei";
import { useControls } from "leva";

import * as THREE from "three";
import { useFrame } from "@react-three/fiber";

import { gsap } from "gsap";

// import { EffectComposer, Outline, SelectiveBloom } from "@react-three/postprocessing";
// import { BlendFunction, Resizer, KernelSize } from "postprocessing";
import state from "../state";

import * as hudStyles from "@styles/HUD.module.scss";

export function Asteroid(props) {
  const { nodes, materials } = useGLTF("/models/asteroid3.glb");

  const asteroidRef = useRef();
  const asteroidMeshRef = useRef();

  const [clicked, setClicked] = useState(false);
  const [direction, setDirection] = useState(new THREE.Vector3());

  // const [isDestroyed, setIsDestroyed] = useState(false);

  // const { position } = useControls("Asteroid", {
  //   position: {
  //     value: [-9, 10, -12],
  //     step: 0.1,
  //     label: "Position",
  //   },
  // });

  const randomMultiplier = (min, max) => {
    return Math.random() * (max - min) + min;
  };

  const [xMultiplier, yMultiplier, zMultiplier] = useMemo( () =>
    Array.from({ length: 3 }, () => randomMultiplier(0.003, 0.015)),
    []
  );

  const [omegaX, omegaY, omegaZ] = useMemo(
    () => Array.from({ length: 3 }, () => randomMultiplier(0.1, 0.18)),
    []
  );

  const [ampX, ampZ] = useMemo(
    () => Array.from({ length: 2 }, () => randomMultiplier(4, 10)),
    []
  );

  const [phaseX, phaseY, phaseZ] = useMemo(
    () => Array.from({ length: 3 }, () => randomMultiplier(0, 2 * Math.PI)),
    []
  );

  const scale = useMemo(() => randomMultiplier(0.15, 0.5), []);

  const [ampY] = useMemo(
    () => Array.from({ length: 1 }, () => randomMultiplier(1, 3)),
    []
  );

  useFrame((state, delta) => {
    asteroidRef.current.rotation.y += delta;
    asteroidRef.current.rotation.x += delta;

    if (clicked) {
      asteroidRef.current.position.x += direction.x * xMultiplier;
      asteroidRef.current.position.y += direction.y * yMultiplier;
      asteroidRef.current.position.z += direction.z * zMultiplier;
    } else {
      asteroidRef.current.position.x =
        ampX * Math.sin((state.clock.elapsedTime) * omegaX + phaseX);
      asteroidRef.current.position.y =
        ampY * Math.cos((state.clock.elapsedTime) * omegaY + phaseY);
      asteroidRef.current.position.z =
        ampZ * Math.cos((state.clock.elapsedTime) * omegaZ + phaseZ);
    }
  });

  const handleClick = (e) => {
    setClicked(true);
    
    const direction = new THREE.Vector3(...e.point);
    setDirection(direction);

    setTimeout(() => {
      setClicked(false);
    }, 7000);
  };

  // useEffect(() => {
  //   if (isDestroyed && asteroidMeshRef.current) {
  //     gsap.set(asteroidMeshRef.current.scale, {
  //       x: 0,
  //       y: 0,
  //       z: 0,
  //     });

  //     gsap.to(asteroidMeshRef.current.scale, {
  //       x: scale,
  //       y: scale,
  //       z: scale,
  //       duration: 0.5,
  //       ease: "power2.out",
  //       delay: 10,
  //       onComplete: () => {
  //         setIsDestroyed(false);
  //       },
  //     });
  //   }
  // }, [isDestroyed]);

  // const addExplosion = (e) => {
  //   setIsDestroyed(true);
  //   state.explosions.push({
  //     guid: Math.random(),
  //     offset: asteroidRef.current.position,
  //     scale: 0.07,
  //   });
  // };

  const handleHover = (e) => {
    const crosshair = document.querySelector(`.${hudStyles.crosshair}`);
    crosshair.classList.add(hudStyles.hover);
  }

  const handleUnhover = (e) => {
    const crosshair = document.querySelector(`.${hudStyles.crosshair}`);
    crosshair.classList.remove(hudStyles.hover);
  }

  return (
    <>
      <group
        ref={asteroidRef}
        {...props}
        dispose={null}
        // onClick={addExplosion}
        onClick={handleClick}
        onPointerEnter={handleHover}
        onPointerLeave={handleUnhover}
      >
        <mesh
          ref={asteroidMeshRef}
          castShadow
          receiveShadow
          geometry={nodes.Cube.geometry}
          material={materials.Material}
          scale={scale}
        />
      </group>
    </>
  );
}

useGLTF.preload("/models.asteroid3.glb");
